

<!doctype html>



<html>

<head>

  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

  <meta name="theme-color" content="#4F7DC9">

  <meta charset="UTF-8">

  <title>Building a basic GPU accelerated application with HIP in C/C&#43;&#43;</title>

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">

  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">

  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">

  <style>

    .success {

      color: #1e8e3e;

    }

    .error {

      color: red;

    }

  </style>


<!-- update the version number as needed -->
<script defer src="/__/firebase/7.9.3/firebase-app.js"></script>
<!-- include only the Firebase features as you need -->
<script defer src="/__/firebase/7.9.3/firebase-auth.js"></script>
<script defer src="/__/firebase/7.9.3/firebase-database.js"></script>
<script defer src="/__/firebase/7.9.3/firebase-messaging.js"></script>
<script defer src="/__/firebase/7.9.3/firebase-storage.js"></script>
<!-- initialize the SDK after all desired features are loaded -->
<script defer src="/__/firebase/init.js"></script>

</head>

<body>

  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>

  <google-codelab codelab-gaid="TO DO"

                  id="URL"

                  title="Building a basic GPU accelerated application with HIP in C/C&#43;&#43;"

                  environment="web"

                  feedback-link="TO DO">

    

      <google-codelab-step label="Introduction" duration="0">

        <p><strong>Last Updated:</strong> 2020-20-07</p>

<p>Over the last few decades, there has been increased interest in using Graphics Processing Units (GPUs) to perform general purpose computing tasks. This practice is often referred to as General Purpose GPU (GPGPU) programming. Using GPUs for general purpose computing tasks gained attention primarily due to the inherent scale of parallelism within GPU hardware that enables faster computation and a reduction in the time-to-solution.</p>

<p>Since GPUs were designed for handling graphics rendering tasks, implementing general purpose routines, like those for numerically solving partial differential equation or optimizing the weights in a neural network, was time-consuming and often error-prone. The continued interest and success of GPGPU computing led to the development of more user-friendly application programming interfaces (APIs) that allow developers to focus more attention on implementing algorithms using the syntax of compiled languages they are more familiar with, rather than thinking about how to express their algorithm in terms of graphics operations.</p>

<h2 is-upgraded><strong>Basics of GPU Accelerated Platforms</strong></h2>

<p>A GPU is an additional hardware component that can perform operations alongside a CPU. GPUs are either integrated into the motherboard or silicon dye alongside a CPU, or are made available through a dedicated interconnect, called the Peripheral Component Interconnect (PCI). The PCI is a physical hardware component that allows data to be transmitted between the CPU and GPU.</p>

<p class="image-container"><img style="width: 348.50px" src="img/eb4f4a95fc0a22c0.png"></p>

<p>On GPU-Accelerated High Performance Computing platforms, you will primarily encounter servers with one or more dedicated GPUs. Dedicated GPUs have an isolated set of compute cores and their own memory space, distinct from the CPU and the CPU&#39;s memory space. The figure above illustrates simple conceptual model of a server with a CPU connected to a single GPU that highlights these features. This conceptual model is purposefully simplified to highlight the first hurdle that all new GPU developers must overcome : managing CPU and GPU memory spaces.</p>

<p>A more subtle aspect of GPU programming, driven by the fact that a GPU is a separate hardware component from the CPU, is the potential for asynchronous activities between the CPU and GPU. When developing a GPU accelerated application, kernels that can execute on the GPU are scheduled for execution by the CPU. Most modern GPU programming APIs provide calls that can force the issuing CPU process to stop and wait for the GPU kernel execution. Further, when a CPU issues multiple kernel execution instructions, these APIs can allow for serialized or asynchronous executions.</p>

<h2 is-upgraded><strong>GPU Programming APIs</strong></h2>

<p>In general, a GPU programming API must provide routines that developers can leverage to allocate and deallocate memory on the GPU, copy memory between the CPU and GPU, and control kernel execution. GPU programming APIs can be classified into two categories</p>

<ol type="1" start="1">

<li>Directive-Based</li>

<li>Kernel-Based</li>

</ol>

<p>When programming with Directive-Based APIs, developers will provide &#34;hints&#34; to the compiler about how to offload sections of code to the GPU. In this approach, the compiler will then generate code for allocating/deallocating memory, copying memory between host and device, and how to parallelize sections of code. This method of GPU programming has the benefit of being able to start running on GPUs quickly with little effort. Additionally, management of CPU and GPU memory is handled &#34;behind-the-scenes&#34; by the compiler and can help limit code complexity. In this case, compilers will more often make decisions that ensure correctness, rather than optimize performance. Because of this, performance tuning often requires verbose compiler hints to limit superfluous data transfer between CPU and GPU and sometimes require alteration of the CPU code.</p>

<p>When programming with Kernel-Based APIs, developers are solely responsible for creating and managing both CPU and GPU memory spaces. Additionally, they must write compute kernels that are consistent with their CPU counterparts and issue explicit calls to launch routines when needed. While this approach increases code complexity and has a higher barrier to entry than Directive-Based approaches, the developer has precise control over the performance of GPU kernels, separate from the counterpart CPU routines. Additionally, the developer can control precisely when data transfers between CPU and GPU occur, allowing for a clear path to minimize time spent crossing the PCI Bus.</p>

<p>The table below provides a breakdown of popular GPU programming APIs, their type, which compilers expose the API, and which GPU platforms the API allows you to program for.  It&#39;s important to keep in mind that directive-based APIs yield varied performance across compilers. Further, Fortran compilers that are 2003 compliant are able to leverage ISO_C_BINDING to expose kernels that can be called from Fortran source code.</p>

<table>

<tr><td colspan="1" rowspan="1"><p><strong>API </strong></p>

</td><td colspan="1" rowspan="1"><p><strong>Type</strong></p>

</td><td colspan="1" rowspan="1"><p><strong>Compiler Support</strong></p>

</td><td colspan="1" rowspan="1"><p><strong>Platforms</strong></p>

</td></tr>

<tr><td colspan="1" rowspan="1"><p>HIP (HIP-Fortran)</p>

</td><td colspan="1" rowspan="1"><p>Kernel</p>

</td><td colspan="1" rowspan="1"><p>hipcc</p>

</td><td colspan="1" rowspan="1"><p>AMD, Nvidia</p>

</td></tr>

<tr><td colspan="1" rowspan="1"><p>OpenMP</p>

</td><td colspan="1" rowspan="1"><p>Directive</p>

</td><td colspan="1" rowspan="1"><p>AOMP, GCC 10, XL</p>

</td><td colspan="1" rowspan="1"><p>AMD, Nvidia</p>

</td></tr>

<tr><td colspan="1" rowspan="1"><p>CUDA</p>

</td><td colspan="1" rowspan="1"><p>Kernel</p>

</td><td colspan="1" rowspan="1"><p>nvcc</p>

</td><td colspan="1" rowspan="1"><p>Nvidia</p>

</td></tr>

<tr><td colspan="1" rowspan="1"><p>CUDA-Fortran</p>

</td><td colspan="1" rowspan="1"><p>Kernel</p>

</td><td colspan="1" rowspan="1"><p>PGI</p>

</td><td colspan="1" rowspan="1"><p>Nvidia</p>

</td></tr>

<tr><td colspan="1" rowspan="1"><p>OpenACC</p>

</td><td colspan="1" rowspan="1"><p>Directive</p>

</td><td colspan="1" rowspan="1"><p>GCC 9, PGI, XL</p>

</td><td colspan="1" rowspan="1"><p>Nvidia</p>

</td></tr>

<tr><td colspan="1" rowspan="1"><p>OpenCL</p>

</td><td colspan="1" rowspan="1"><p>Kernel</p>

</td><td colspan="1" rowspan="1"><p>All</p>

</td><td colspan="1" rowspan="1"><p>All</p>

</td></tr>

</table>

<h2 is-upgraded><strong>What you will build</strong></h2>

<p>In this codelab, you are going to transition a mini-application, written in C, from a CPU-only application to a portable GPU accelerated application, using AMD&#39;s HIP. </p>

<h2 is-upgraded><strong>What you will learn</strong></h2>

<ul>

<li>How to manage GPU memory with HIP</li>

<li>How to launch GPU accelerated kernels with HIP</li>

<li>How to build GPU accelerated C/C++ applications for AMD and Nvidia platforms with a simple Makefile</li>

<li>How to verify GPU memory allocation and kernel execution with the rocprof profiler</li>

</ul>

<h2 is-upgraded><strong>What you will need</strong></h2>

<ul>

<li>A compute platform with AMD or Nvidia GPU(s)</li>

<li>Linux operating system (e.g. Debian, Ubuntu, CentOS, or RHEL)</li>

<li>Working installation of <a href="https://rocm-documentation.readthedocs.io/en/latest/Installation_Guide/Installation-Guide.html" target="_blank">ROCm-dev</a></li>

<li>Basic Command-Line Linux Experience</li>

<li>Working C or C++ compiler</li>

</ul>





      </google-codelab-step>

    

      <google-codelab-step label="Clone and Run the Demo Application (CPU-Only)" duration="15">

        <p>In this section, we introduce the demo application and walk through building and verifying the example. It&#39;s important to make sure that the code produces the expected result as we will be using the CPU generated model output to ensure that the solution does not change when we port to the GPU. </p>

<aside class="special"><p><strong>Tip:</strong> In practice, it&#39;s ideal to define tests for all of your routines as standalone (unit-tests) and/or in concert together (integration-tests). These tests would ideally be run regularly during development and with every commit to your code&#39;s repository.</p>

</aside>

<p>This application executes a 2-D smoothing operation on a square grid of points. The program proceeds as follows</p>

<ol type="1" start="1">

<li>Process command line arguments</li>

<li>Allocate memory for smoother class - 5x5 stencil with Gaussian weights</li>

<li>Allocate memory for function and smoothed function</li>

<li>Initialize function on CPU and report function to file</li>

<li>Call smoothing function</li>

<li>Report smoothed function to file</li>

<li>Clear memory</li>

</ol>

<h2 is-upgraded><strong>Code Structure</strong></h2>

<p>This application&#39;s src directory contains the following files</p>

<ol type="1" start="1">

<li>smoother.c : Defines a simple data structure that stores the smoothing operators weights and the routines for allocating memory, deallocating memory, and executing the smoothing operation.</li>

<li>main.c : Defines the main program that sets up the 2-D field to be smoothed and managed file IO.</li>

<li>makefile : A simple makefile is to build the application binary <code>smoother2d</code>.</li>

<li>viz.py : A python script for creating plots of the smoother2d output</li>

</ol>

<h2 is-upgraded><strong>Install and Verify the Application</strong></h2>

<p>To get started...</p>

<ol type="1" start="1">

<li>Clone the repository</li>

</ol>

<pre><code>$ git clone URL NEEDED</code></pre>

<ol type="1" start="2">

<li>Build the smoother2d application. Keep in mind, the compiler is set to gcc by default in the provided makefile.</li>

</ol>

<pre><code>$ cd amd-codelab-demos/smoothing2d/src

$ make</code></pre>

<ol type="1" start="3">

<li>Test run the example. The application takes two arguments. The first argument is the number of grid cells, and the second argument is the number of times the smoothing operator is applied.</li>

</ol>

<p>$ ./smoother2d 1000 10</p>

<h2 is-upgraded><strong>Visualize the output (Optional)</strong></h2>

<p>You can visualize the output with the provided <code>viz.py</code> python script. We recommend using virtual environments to install the script&#39;s dependencies</p>

<ol type="1" start="1">

<li>Start a virtual environment</li>

</ol>

<pre><code>$ python3 -m venv env

$ source env/bin/activate</code></pre>

<ol type="1" start="2">

<li>Install the required packages</li>

</ol>

<pre><code>(env)$ pip3 install -r requirements.txt</code></pre>

<ol type="1" start="3">

<li>Execute viz.py</li>

</ol>

<pre><code>(env)$ python3 ./viz.py</code></pre>

<p>This script saves a figure to <code>function.eps</code>. This figure shows the initial 2-D function before smoothing on the top and the smoothed field on the bottom. An example of the visualized output from the <code>smoother2d</code> example program. The initial field is shown on the top, and the smoothed field is shown on the bottom after 10 iterations.<img style="width: 624.00px" src="img/339004e3869450ed.png"></p>

<h2 is-upgraded><strong>Profile the Application</strong></h2>

<p>Before starting any GPU porting exercise, it is important to profile your application to find hotspots where your application spends most of its time. Further, it is helpful to keep track of the runtime of the routines in your application so that you can later assess whether or not the GPU porting has resulted in improved performance. Ideally, your GPU-Accelerated application should outperform CPU-Only versions of your application when fully subscribed to available CPUs on a compute node.</p>

<aside class="special"><p><strong>Tip:</strong> To obtain a fair comparison between CPU-Only and GPU-Accelerated versions of your application,  you will want to compare the run-time between fully-subscribed CPU-only routines and the GPU-ported routines. </p>

<p>If your application is not parallelized on the CPU, you can estimate the idealized runtime on the CPU by dividing the serial runtime by the number of cores available on your target hardware.</p>

</aside>

<p>There are a number of open-source tools available for profiling C/C++ and Fortran applications, including <a href="https://www.cs.uoregon.edu/research/tau/home.php" target="_blank">Tau</a>, <a href="https://www.vi-hps.org/projects/score-p" target="_blank">Score-P</a>, <a href="https://vampir.eu/" target="_blank">Vampir</a>, and <a href="https://www.scalasca.org/" target="_blank">Scalasca</a>. In this tutorial, we are going to generate a profile and call graph using gprof. </p>

<h3 is-upgraded><strong>Create the profile</strong></h3>

<ol type="1" start="1">

<li>Add -pg flag to the OPT variable in the provided Makefile.</li>

</ol>

<pre><code>OPT=-O2 -pg</code></pre>

<ol type="1" start="2">

<li>Remove files from your previous build.</li>

</ol>

<pre><code>$ make clean</code></pre>

<ol type="1" start="3">

<li>Make the smoother2d application</li>

</ol>

<pre><code>$ make</code></pre>

<ol type="1" start="4">

<li>Run the application. When the -pg flag is passed to the gcc compiler, executions of the application will create a file called gmon.out</li>

</ol>

<pre><code>$ ./smoother2d 1000 10</code></pre>

<ol type="1" start="5">

<li>Create the profile</li>

</ol>

<pre><code>$ gprof ./smoother2d gmon.out &gt; profile.txt</code></pre>

<aside class="special"><p><strong>Tip:</strong> If you are working with compilers other than GNU compilers, you can use <a href="https://developer.mantidproject.org/ProfilingWithValgrind.html" target="_blank">Valgrind&#39;s Callgrind</a> command line tool to create call-graphs and to conduct hotspot analysis.</p>

</aside>

<h3 is-upgraded><strong>Interpret the profile and callgraph</strong></h3>

<p><code>gprof</code> provides a flat profile and a summary of your application&#39;s call structure indicating dependencies within your source code as a call graph. A <strong><em>call tree</em></strong> depicts the relationships between routines in your source code. Combining timing information with a call graph will help you plan the order in which you port routines to the GPU.</p>

<p>The first section of the gprof output is the flat-profile. An example flat-profile for the <code>smoother2d</code> application is given below. The flat-profile provides a list of routines in your application, ordered by the percent time your program spends within those routines from greatest to least. Beneath the flat-profile, gprof provides documentation of each of the columns for your convenience.</p>

<pre><code>  %   cumulative   self              self     total           

 time   seconds   seconds    calls  ms/call  ms/call  name    

 95.24      1.16     1.16       10   116.19   116.19  smoothField

  2.46      1.19     0.03       10     3.00     3.00  resetF

  2.46      1.22     0.03                             main

  0.00      1.22     0.00        1     0.00     0.00  smootherFree

  0.00      1.22     0.00        1     0.00     0.00  smootherInit</code></pre>

<p>Let&#39;s now take a look at at the call tree. This call tree has five entries, one for each routine in our program. The right-most field for each entry indicates the routines that called each routine and that are called by each routine. </p>

<p>For <code>smoother2d</code>, the first entry shows that main calls <code>smoothField</code>, <code>resetF</code>, <code>smootherInit</code>, and <code>smootherFree</code>. Further, the called column indicates that smoothField and resetF routines are shown to be called 10 times (in this case) by main. The self and children columns indicate that main spends 0.03s executing instructions in main and 1.19s in calling other routines. Further, of those 1.19s, 1.16s are spent in <code>smoothField</code> and 0.03 are spent in <code>resetF</code>. </p>

<pre><code>index % time    self  children    called     name

                                                 &lt;spontaneous&gt;

[1]    100.0    0.03    1.19                 main [1]

                1.16    0.00      10/10          smoothField [2]

                0.03    0.00      10/10          resetF [3]

                0.00    0.00       1/1           smootherInit [5]

                0.00    0.00       1/1           smootherFree [4]

-----------------------------------------------

                1.16    0.00      10/10          main [1]

[2]     95.1    1.16    0.00      10         smoothField [2]

-----------------------------------------------

                0.03    0.00      10/10          main [1]

[3]      2.5    0.03    0.00      10         resetF [3]

-----------------------------------------------

                0.00    0.00       1/1           main [1]

[4]      0.0    0.00    0.00       1         smootherFree [4]

-----------------------------------------------

                0.00    0.00       1/1           main [1]

[5]      0.0    0.00    0.00       1         smootherInit [5]

-----------------------------------------------</code></pre>

<aside class="special"><p><strong>Tip:</strong> You can use the open-source <a href="https://github.com/jrfonseca/gprof2dot" target="_blank">gprof2dot</a> to create visualizations of gprof output to help interpret the profile and call-graph for more complex applications.</p>

</aside>

<h3 is-upgraded><strong>Next steps</strong></h3>

<p>Now that we have a profile and an understanding of the call structure of the application, we can now plan our port to GPUs. First, we will focus on porting the smoothField routine and the necessary data to the GPU, since smoothField takes up the majority of the run time. </p>

<p>When we port this routine, we will introduce data allocation on the GPU and data copies between CPU and GPU. This data movement may potentially increase the overall application runtime, even if the smoothField routine performs better. In this event, we will then work on minimizing data movements between CPU and GPU. </p>

<aside class="special"><p class="image-container"><img style="width: 231.82px" src="img/fb9a02e8f06a74cb.png"></p>

<p><strong>Tip:</strong> As a general strategy, it is recommended that you approach GPU porting in small incremental steps. Each step should consist of (1) profiling, (2) planning, (3) implementing planned changes &amp; verifying the application output, and (4) committing the changes to your repository.</p>

</aside>





      </google-codelab-step>

    

      <google-codelab-step label="Moving Data to the GPU with HIP" duration="20">

        <aside class="special"><p><strong>Tip: </strong>Before getting started in this section, make sure that <code>hipcc</code> is in your path by running <code>hipcc --version</code>. Additionally, if you are on an Nvidia platform, make sure that <code>nvcc</code> is in your path by running <code>nvcc --version</code>.</p>

</aside>

<p>In the <code>smoother2d</code> application, we have seen that the <code>smoothField</code> routine, called by <code>main</code>, takes up the most time. Looking at the function call in <code>main.c</code> and the <code>smoothField</code> routine in <code>smoother.c</code>, we see that this routine takes in a <code>smoother</code> object, a real array pointer <code>f</code>, and integers <code>nx</code> and <code>ny</code> that are passed by value.</p>

<pre><code> 81   for( int iter=0; iter&lt;nIter; iter++){

 82     // Run the smoother

 83     smoothField( &amp;smoothOperator, f, smoothF, nx, ny );

 84     // Reassign smoothF to f

 85     resetF( f, smoothF, nx, ny );

 86   } </code></pre>

<p>In order to offload <code>smoothField</code> to the GPU, we will need to copy <code>smoothOperator</code> class data and the <code>f</code> array to the GPU. After calling <code>smoothF</code>, we will eventually want to copy <code>smoothF</code> back to the CPU before calling <code>resetF</code>.</p>

<h2 is-upgraded><strong>Copy smoothOperator class data to the GPU</strong></h2>

<p>The <code>smoothField</code> routine uses the <code>smoothOperator -&gt; weights</code> array when applying the operator. Because of this, you will need to create and allocate a device copy of the weights array. After filling in the weights values on the CPU, you can copy the values over to the device array.</p>

<ol type="1" start="1">

<li>Include the hip runtime header at the top of <code>smoother.c</code> so that you can make HIP API calls.</li>

</ol>

<pre><code>#include &lt;math.h&gt;

#include &lt;stdio.h&gt;

#include &lt;stdlib.h&gt;

#include &#34;precision.h&#34;

#include &#34;smoother.h&#34;

#include &lt;hip/hip_runtime.h&gt;</code></pre>

<ol type="1" start="2">

<li>Declare a real pointer attribute in the smoother class in <code>smoother.h</code> for a device copy of the smoother weights.</li>

</ol>

<pre><code>typedef struct smoother{

  int dim;

  real *weights;

  real *weights_dev;

}smoother;</code></pre>

<ol type="1" start="3">

<li>Insert a call to <a href="https://rocm-developer-tools.github.io/HIP/group__Memory.html#ga4c6fcfe80010069d2792780d00dcead2" target="_blank">hipMalloc</a> in <code>smootherInit</code> to allocate <code>weights_dev</code> on the GPU and insert a call to <a href="https://rocm-developer-tools.github.io/HIP/group__Memory.html#gac1a055d288302edd641c6d7416858e1e" target="_blank">hipMemcpy</a> in <code>smootherInit</code> to copy <code>weights</code> to <code>weights_dev</code>.</li>

</ol>

<pre><code>// Allocate space for the device copy of the smoothing weights

  hipMalloc(&amp;smoothOperator-&gt;weights_dev,N*N*sizeof(real));

// Copy weights from the host to the device

  hipMemcpy(smoothOperator-&gt;weights_dev,

            smoothOperator-&gt;weights,

            N*N*sizeof(real),

            hipMemcpyHostToDevice);</code></pre>

<ol type="1" start="4">

<li>Insert a call to <a href="https://rocm-developer-tools.github.io/HIP/group__Memory.html#ga740d08da65cae1441ba32f8fedb863d1" target="_blank">hipFree</a> in <code>smootherFree</code> to deallocate GPU memory held by <code>weights_dev</code>.</li>

</ol>

<pre><code>  hipFree(smoothOperator-&gt;weights_dev);</code></pre>

<ol type="1" start="5">

<li>Change the compiler in the <code>Makefile</code> to <code>hipcc</code> and set the necessary compiler flags. <br>(AMD Platforms only) Set the necessary compiler flags. You can determine your GPU target type by running <a href="https://github.com/RadeonOpenCompute/rocminfo" target="_blank"><code>rocminfo</code></a>. Once you have determined the target type, you can add <code>--amdgpu-target=TARGET</code>. <a href="https://github.com/RadeonOpenCompute/hcc/wiki#compiling-for-different-gpu-architectures" target="_blank">The ROCm Wiki</a> provides more information on compiling for different AMD GPU targets.</li>

</ol>

<pre><code>CC=hipcc

OPT=-O0 -g

LIB=-lm

INC=</code></pre>

<aside class="special"><p><strong>Tip: </strong>To build code with hipcc on Nvidia platforms, you will need to set the environment variable <code>HIP_PLATFORM</code> to <code>nvcc</code>.</p>

<p><code>export HIP_PLATFORM=nvcc</code></p>

</aside>

<p>Once you have completed the code and Makefile modifications, you can now compile <code>smoother2d</code> and verify that data allocated and copied to the GPU.</p>

<ol type="1" start="1">

<li>Copy existing CPU data to a <code>reference/</code> subdirectory for later comparison. Whenever we make a change to the code, we will compare output with this reference data.</li>

</ol>

<pre><code>$ mkdir ./reference

$ mv function.txt smooth-function.txt ./reference/</code></pre>

<ol type="1" start="2">

<li>Remove the <code>*.o</code> files and the <code>smoother2d</code> binary to ensure a clean build and make a new <code>smoother2d</code> binary</li>

</ol>

<pre><code>$ make clean &amp;&amp; make smoother2d</code></pre>

<ol type="1" start="3">

<li>Run <code>smoother2d</code> with the same input parameters as you did in the previous section and verify the output is unchanged. We use the diff command line utility to compare the output files and the reference files. If there are no differences, diff will produce no output.</li>

</ol>

<pre><code>$ ./smoother2d 1000 10

$ diff function.txt reference/function.txt

$ diff smooth-function.txt reference.txt</code></pre>

<ol type="1" start="4">

<li>Verify that data is allocated on the GPU and that data is copied from the CPU to GPU by using a profiler.</li>

</ol>

<ol type="1" start="1">

<li>For AMD platforms, use <code>rocprof</code> with the <code>--hip-trace</code> flag. Running rocprof will create a file called <code>profile.json</code>. The contents of <code>profile.json</code> will show calls to <code>hipMalloc</code>, <code>hipMemcpy</code>, and <code>hipFree</code>.</li>

<li>For Nvidia platforms, use <code>nvprof</code>. When running on Nvidia platforms, you can expect to see calls to <code>cudaMalloc</code>, <code>cudaMemcpy</code>, and <code>cudaFree</code>.</li>

</ol>

<pre><code>$ nvprof ./smoother2d 1000 10

==8725== NVPROF is profiling process 8725, command: ./smoother2d 1000 10

==8725== Profiling application: ./smoother2d 1000 10

==8725== Profiling result:

            Type  Time(%)      Time     Calls       Avg       Min       Max  Name

 GPU activities:  100.00%  1.4400us         1  1.4400us  1.4400us  1.4400us  [CUDA memcpy HtoD]

      API calls:   99.56%  174.39ms         1  174.39ms  174.39ms  174.39ms  cudaMalloc

                    0.22%  381.82us        97  3.9360us     172ns  224.16us  cuDeviceGetAttribute

                    0.12%  207.16us         1  207.16us  207.16us  207.16us  cuDeviceTotalMem

                    0.09%  159.58us         1  159.58us  159.58us  159.58us  cuDeviceGetName

                    0.01%  13.386us         1  13.386us  13.386us  13.386us  cudaMemcpy

                    0.01%  10.374us         1  10.374us  10.374us  10.374us  cudaFree

                    0.00%  3.8930us         1  3.8930us  3.8930us  3.8930us  cuDeviceGetPCIBusId

                    0.00%  1.7600us         3     586ns     247ns  1.2440us  cuDeviceGetCount

                    0.00%     753ns         2     376ns     235ns     518ns  cuDeviceGet

                    0.00%     282ns         1     282ns     282ns     282ns  cuDeviceGetUuid</code></pre>

<ol type="1" start="5">

<li>Commit your changes to your local git repository.</li>

</ol>

<pre><code>$ git add smoother.h smoother.c makefile &amp;&amp; git commit</code></pre>

<h2 is-upgraded><strong>Copy f and smoothF to the GPU</strong></h2>

<ol type="1" start="1">

<li>Include the hip runtime header at the top of <code>main.c</code> so that you can make HIP API calls.</li>

</ol>

<pre><code>#include &lt;math.h&gt;

#include &lt;stdio.h&gt;

#include &lt;stdlib.h&gt;

#include &#34;precision.h&#34;

#include &#34;smoother.h&#34;

#include &lt;hip/hip_runtime.h&gt;</code></pre>

<ol type="1" start="2">

<li>Declare real pointers for f and smoothF in main.c</li>

</ol>

<pre><code>int main( int argc, char *argv[] )  {

  smoother smoothOperator;

  int nx, ny, nElements;

  int nIter;

  real dx;

  real *f, *smoothF;

  real *f_dev, *smoothF_dev;</code></pre>

<ol type="1" start="3">

<li>Insert calls to hipMalloc for f_dev and smoothF_dev</li>

</ol>

<pre><code>  // Create the smoother

  smootherInit(&amp;smoothOperator);



  // Allocate space for the function we want to smooth

  f  = (real*)malloc( nElements*sizeof(real) );

  smoothF = (real*)malloc( nElements*sizeof(real) );



  hipMalloc(&amp;f_dev, nElements*sizeof(real));

  hipMalloc(&amp;smoothF_dev, nElements*sizeof(real));</code></pre>

<ol type="1" start="4">

<li>Insert hipMemcpy call to update f_dev (host to device) prior to calling smoothField and to update smoothF_dev (device to host) after calling smoothField.</li>

</ol>

<pre><code>    hipMemcpy(f_dev, f, nElements*sizeof(real), hipMemcpyHostToDevice);



    smoothField( &amp;smoothOperator, f, smoothF, nx, ny );



    hipMemcpy(smoothF, smoothF_dev, nElements*sizeof(real), hipMemcpyDeviceToHost);</code></pre>

<ol type="1" start="5">

<li>Verify that the application still builds. </li>

</ol>

<pre><code>$ make</code></pre>

<ol type="1" start="6">

<li>(Optional) You can verify that data is being copied between the CPU and GPU by using a profiler</li>

</ol>

<ol type="1" start="1">

<li>For AMD platforms, use <code>rocprof</code> with the <code>--hip-trace</code> flag. Running rocprof will create a file called <code>profile.json</code>. The contents of <code>profile.json</code> will show calls to <code>hipMalloc</code>, <code>hipMemcpy</code>, and <code>hipFree</code>.</li>

<li>For Nvidia platforms, use <code>nvprof</code>. At this stage, you should see three calls to <code>cudaMalloc</code>, three calls to <code>cudaFree</code>, ten calls to <code>cudaMemcpy (Device to Host)</code>, and 11 calls to <code>cudaMemcpy (Host to Device)</code>.</li>

</ol>

<pre><code>$ nvprof ./smoother2d 1000 10

==23287== NVPROF is profiling process 23287, command: ./smoother2d 1000 10

==23287== Profiling application: ./smoother2d 1000 10

==23287== Profiling result:

            Type  Time(%)      Time     Calls       Avg       Min       Max  Name

 GPU activities:   52.12%  4.6421ms        10  464.21us  427.18us  589.69us  [CUDA memcpy DtoH]

                   47.88%  4.2636ms        11  387.60us  1.4720us  511.96us  [CUDA memcpy HtoD]

      API calls:   93.92%  194.18ms         3  64.727ms  135.75us  193.88ms  cudaMalloc

                    5.20%  10.757ms        21  512.25us  22.255us  778.80us  cudaMemcpy

                    0.39%  809.35us        97  8.3430us     537ns  396.19us  cuDeviceGetAttribute

                    0.25%  526.66us         1  526.66us  526.66us  526.66us  cuDeviceTotalMem

                    0.16%  339.77us         3  113.26us  2.7010us  176.22us  cudaFree

                    0.06%  115.21us         1  115.21us  115.21us  115.21us  cuDeviceGetName

                    0.00%  4.4240us         3  1.4740us     700ns  2.9380us  cuDeviceGetCount

                    0.00%  4.3810us         1  4.3810us  4.3810us  4.3810us  cuDeviceGetPCIBusId

                    0.00%  2.5650us         2  1.2820us     662ns  1.9030us  cuDeviceGet

                    0.00%  1.0790us         1  1.0790us  1.0790us  1.0790us  cuDeviceGetUuid</code></pre>

<aside class="warning"><p><strong>Caution: </strong>Copying smoothF_dev to <code>smoothF</code> will produce an incorrect result until the <code>smoothField</code> routine is offloaded to the GPU, which we will complete in the next section. This happens because <code>smoothF_dev</code> currently contains uninitialized data that we use to update <code>smoothF</code>.</p>

</aside>

<h2 is-upgraded><strong>Next steps</strong></h2>

<p>At this point, you now have the necessary data declared on the GPU. Additionally, you used hipMemcpy to make the input to smoothField available on the GPU. In the next step, you will create a HIP kernel that will run the smoothField algorithm on the GPU and replace the call to smoothField with a call to launch this kernel.</p>





      </google-codelab-step>

    

      <google-codelab-step label="HIP Kernel Launch Basics" duration="10">

        <p>Routines that are executed on the GPU are typically scheduled to run by issuing instructions from the host (CPU). In HIP, a GPU kernel is launched through a call to hipLaunchKernelGGL. When scheduling GPU kernel execution,  you specify </p>

<ol type="1" start="1">

<li>The kernel name,</li>

<li>The number of threads and the thread grouping,</li>

<li>The amount of Local Data Share (LDS) memory (Shared Memory) per block, and </li>

<li>The stream ID.</li>

</ol>

<h2 is-upgraded><strong>Threads, Blocks, and LDS Memory</strong></h2>

<p>When a kernel is launched, all requested threads on the GPU execute the kernel instructions concurrently. How the threads are scheduled to execute the instructions depends on the thread grouping. Threads are grouped into blocks in the HIP and CUDA programming models. Threads within a block are able to share LDS memory and L1 Cache on GPU Compute Units (Streaming Multiprocessor in Nvidia/CUDA terminology).</p>

<p>Within a HIP kernel, you are able to use HIP intrinsics to determine the unique ID of a thread. This allows you to codify memory access patterns for each thread within a kernel and expose SIMD parallelism. These intrinsics are summarized the table below.</p>

<table>

<tr><td colspan="1" rowspan="1"><p><strong>Intrinsic</strong></p>

</td><td colspan="1" rowspan="1"><p><strong>Description</strong></p>

</td></tr>

<tr><td colspan="1" rowspan="1"><p>hipBlockIDx_[x,y,z]</p>

</td><td colspan="1" rowspan="1"><p>The block ID in the [x,y,z] grid directions.</p>

</td></tr>

<tr><td colspan="1" rowspan="1"><p>hipBlockDimx_[x,y,z]</p>

</td><td colspan="1" rowspan="1"><p>The number of threads within each block in the [x,y,z] grid directions.</p>

</td></tr>

<tr><td colspan="1" rowspan="1"><p>hipThreadIDx_[x,y,z]</p>

</td><td colspan="1" rowspan="1"><p>The local thread ID within a block in the [x,y,z] block directions.</p>

</td></tr>

</table>

<aside class="special"><p><strong>Note:</strong> Block dimensions (threads-per-block) and Grid dimensions (number-of-blocks) are expressed as <a href="https://github.com/ROCm-Developer-Tools/HIP/blob/master/docs/markdown/hip_kernel_language.md#dim3" target="_blank">dim3</a> variables, giving 3 dimensions (x,y,z). </p>

</aside>

<h3 is-upgraded><strong>Example</strong></h3>

<p>To see how this works, consider this simple example kernel that takes in a device array and returns the same array multiplied by two.</p>

<pre><code>__global__ void myKernel(int N, double *d_a) {

  int i = hipThreadIdx_x + hipBlockIdx_x*hipBlockDim_x;

  if (i&lt;N) {

    d_a[i] *= 2.0;

  }

}</code></pre>

<p>In this example, when the kernel is launched, each thread will calculate i based on its thread ID within a block, its block ID, and the number of threads-per-block (hipBlockDimx_x). A conditional is added to ensure that threads only access in-bounds addresses of d_a. Provided this conditional is met for a thread, that thread will double the i-th element of d_a, concurrently with other threads.</p>

<h3 is-upgraded><strong>Best practice</strong></h3>

<p>On AMD GPUs, threads in a block are executed in 64-wide chunks called &#34;wavefronts&#34;. Because of this, it is good practice is to make block sizes a multiple of 64 on AMD GPUs.</p>

<p>On Nvidia GPUs, threads in a block are executed in 32-wide chunks called &#34;warps&#34; and it is good practice is to make the block size a multiple of 32.</p>

<aside class="warning"><p><strong>Caution: </strong>The number of threads per block, number of blocks, and the amount of local dynamic memory per block are limited; these limits can be found using <a href="https://github.com/RadeonOpenCompute/rocminfo" target="_blank">rocminfo</a> on AMD platforms and the <a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html#running-binaries" target="_blank">deviceQuery CUDA-Toolkit example</a> on Nvidia platforms. </p>

</aside>

<h2 is-upgraded><strong>Streams</strong></h2>

<p>In this codelab, we will always set the stream ID to 0. Using multiple streams is useful when you want to run multiple GPU kernels concurrently. This strategy is useful when you are having difficulty keeping GPUs fully subscribed and you have code that has instruction-level parallelism.</p>





      </google-codelab-step>

    

      <google-codelab-step label="Offload the Smoothing Kernel to the GPU" duration="20">

        <p>In this section, you will offload the smoothField routine to the GPU.</p>

<h2 is-upgraded><strong>Planning the GPU port</strong></h2>

<p>Let&#39;s look at the smoothField routine from smoother.c</p>

<pre><code>void smoothField( struct smoother *smoothOperator, real *f, real *smoothF, int nX, int nY )

{

  int iel, ism;

  int N = (real)smoothOperator-&gt;dim;

  int buf = (real)(smoothOperator-&gt;dim-1)/2.0;

  real smLocal;



  for( int j=buf; j &lt; nY-buf; j++ ){

    for( int i=buf; i &lt; nX-buf; i++ ){

      smLocal = 0.0;

      for( int jj=-buf; jj &lt;= buf; jj++ ){

        for( int ii=-buf; ii &lt;= buf; ii++ ){

          iel = (i+ii)+(j+jj)*nX;

          ism = (ii+buf) + (jj+buf)*N;

          smLocal += f[iel]*smoothOperator-&gt;weights[ism];

        }

      }

      iel = i+j*nX;

      smoothF[iel] = smLocal;

    }

  }

}</code></pre>

<p>The outer loops, over i and j, are tightly nested loops over a 2-D grid. The size of these loops are nY-2*buf and nX-2*buf. The values of nX and nY are determined by the user through the first command line argument (we have been using 1000), and buf is 2 (smoothOperator-&gt;dim=5; see smootherInit). Within the i and j loops, we carry out a reduction operation for smLocal and then assign the value to each element of smoothF.</p>

<p>In the smoothField algorithm, the order in which we execute the i and j loops does not matter. Further, the size of each loop is O(1000) for the example we&#39;re working with. A good strategy for offloading this routine to the GPU is to have each GPU thread execute the instructions within the i and j loops. Ideally, then we want each thread to execute something the following</p>

<pre><code>    real smLocal = 0.0;

    for( int jj=-buf; jj &lt;= buf; jj++ ){

      for( int ii=-buf; ii &lt;= buf; ii++ ){

        iel = (i+ii)+(j+jj)*nX;

        ism = (ii+buf) + (jj+buf)*N;

        smLocal += f[iel]*smoothOperator-&gt;weights[ism];

      }

    }

    iel = i+j*nX;

    smoothF[iel] = smLocal;</code></pre>

<p>Notice now the i and j loops are gone. Within the HIP kernel, we can calculate i and j from hipThreadIdx_[x,y], hipBlockIdx_[x,y], and hipBlockDim_[x,y], assuming that we will launch the kernel with 2-D Grid and Block dimensions. You can use something like the following to calculate i and j.</p>

<pre><code>  size_t i = hipThreadIdx_x + hipBlockIdx_x*hipBlockDim_x;

  size_t j = hipThreadIdx_y + hipBlockIdx_y*hipBlockDim_y;</code></pre>

<aside class="special"><p><strong>Note:</strong> hipThreadIdx_[x,y] and hipBlockIdx_[x,y] are 0-based indices.</p>

</aside>

<p>Within the main program, you will be able to launch the GPU kernel, but you will need to calculate the Grid and Block Dimensions. For now, let&#39;s assume that the number of threads-per-block in the i and j loop dimensions (x and y directions) is fixed at 16. With the number of threads-per-block (in each direction) chosen, you can calculate the grid dimensions, by requiring the x and y grid dimensions to be greater than or equal to the i and j loop sizes, respectively.</p>

<pre><code>  int buf = (real)(smoothOperator-&gt;dim-1)/2.0;

  int threadsPerBlockX = 16;

  int threadsPerBlockY = 16;

  int gridDimX = (nX-2*buf)/threadsPerBlockX + 1;

  int gridDimY = (nY-2*buf)/threadsPerBlockY + 1;</code></pre>

<aside class="special"><p><strong>Note:</strong> In general, the number of threads-per-block will impact the application runtime and you will want to use a suitable profiler to help optimize performance. </p>

<p>On AMD platforms, threads in a block are executed in 64-wide chunks called &#34;wavefronts&#34; and it is good practice is to make the block size a multiple of 64.</p>

<p>On Nvidia platforms, threads in a block are executed in 32-wide chunks called &#34;warps&#34; and it is good practice is to make the block size a multiple of 32.</p>

</aside>

<h2 is-upgraded><strong>Implement the Changes</strong></h2>

<ol type="1" start="1">

<li>Add a new routine, smoothField_gpu, to smoother.c. This routine needs to be of type __global__ so that it can be launched on the GPU (device) from the CPU (host) using hipLaunchKernelGGL.</li>

</ol>

<pre><code>__global__ void smoothField_gpu( real *weights_dev, real *f_dev, real *smoothF_dev, int nX, int nY, int N )

{

  int buf = (real)(N-1)/2.0;

  size_t i = hipThreadIdx_x + hipBlockIdx_x*hipBlockDim_x + buf;

  size_t j = hipThreadIdx_y + hipBlockIdx_y*hipBlockDim_y + buf;

  int iel, ism;

  

  if( i &gt;= buf &amp;&amp; i &lt; nX-buf &amp;&amp; j &gt;= buf &amp;&amp; j&lt; nY-buf){

    real smLocal = 0.0;

    for( int jj=-buf; jj &lt;= buf; jj++ ){

      for( int ii=-buf; ii &lt;= buf; ii++ ){

        iel = (i+ii)+(j+jj)*nX;

        ism = (ii+buf) + (jj+buf)*N;

        smLocal += f_dev[iel]*weights_dev[ism];

      }

    }

    iel = i+j*nX;

    smoothF_dev[iel] = smLocal;

  }

}</code></pre>

<aside class="special"><p><strong>Note:</strong> We&#39;ve added <code>buf</code> to <code>i</code> and <code>j</code> since the original loops began at <code>i=buf</code> and <code>j=buf</code>. Also, notice that we&#39;ve added conditionals to safely ensure that threads do not step outside of the memory bounds of <code>f_dev</code>, <code>weights_dev</code>, and <code>smoothF_dev</code>.</p>

</aside>

<ol type="1" start="2">

<li>Calculate the Block and Grid dimensions in main.c. You can place this block of code just before the iteration loop</li>

</ol>

<pre><code>  int buf = (real)(smoothOperator-&gt;dim-1)/2.0;

  int threadsPerBlockX = 16;

  int threadsPerBlockY = 16;

  int gridDimX = (nX-2*buf)/threadsPerBlockX + 1;

  int gridDimY = (nY-2*buf)/threadsPerBlockY + 1;</code></pre>

<ol type="1" start="3">

<li>Replace the smoothField call in main.c with a kernel launch call for smoothField_gpu</li>

</ol>

<pre><code>    // Copy f from host to device : f is input to `smoothField`

    hipMemcpy(f_dev, f, nElements*sizeof(real), hipMemcpyHostToDevice);



    // Run the smoother

    hipLaunchKernelGGL((smoothField_gpu), dim3(gridDimX,gridDimY,1), dim3(threadsPerBlockX,threadsPerBlockY,1), 0, 0,

                        smoothOperator.weights_dev, f_dev, smoothF_dev, nx, ny, smoothOperator.dim );



    // Copy smoothF_dev from device to host

    hipMemcpy(smoothF, smoothF_dev, nElements*sizeof(real), hipMemcpyDeviceToHost);</code></pre>

<ol type="1" start="4">

<li>Rebuild the application. For Nvidia Platforms, you will need to set <code>OPT=-O0 -g -fmad=false</code> before recompiling.</li>

</ol>

<aside class="warning"><p><strong>Caution: </strong>In order to obtain bit-for-bit correctness on Nvidia Platforms, you must add the <code>-fmad=false</code> flag to the <code>OPT</code> variable in the Makefile. This flag disables fused multiply-add operations. Fused Multiply-Add (FMA) operations on the GPU result in improved performance but can cause a difference in the computed solution between <code>smoothField</code> and <code>smoothField_gpu</code>.</p>

</aside>

<pre><code>$ make clean &amp;&amp; make</code></pre>

<ol type="1" start="5">

<li>Verify that the solution output agrees with your reference output</li>

</ol>

<pre><code>$ ./smoother2d 1000 10

$ diff function.txt reference/function.txt

$ diff smooth-function.txt reference/smooth-function.txt</code></pre>

<ol type="1" start="6">

<li>You can verify that the HIP Kernel is running on the GPU by using a profiler.</li>

</ol>

<ol type="1" start="1">

<li>For AMD platforms, use <code>rocprof</code> with the <code>--hip-trace</code> flag. Running rocprof will create a file called <code>profile.json</code>. </li>

<li>For Nvidia platforms, use <code>nvprof</code>. </li>

</ol>

<pre><code>$ nvprof ./smoother2d 1000 10

==9394== NVPROF is profiling process 9394, command: ./smoother2d 1000 10

==9394== Profiling application: ./smoother2d 1000 10

==9394== Profiling result:

            Type  Time(%)      Time     Calls       Avg       Min       Max  Name

 GPU activities:   53.96%  10.307ms        10  1.0307ms  1.0293ms  1.0337ms  smoothField_gpu(float*, float*, float*, int, int, int)

                   23.97%  4.5788ms        12  381.57us  1.4720us  522.30us  [CUDA memcpy HtoD]

                   22.07%  4.2150ms        10  421.50us  407.71us  463.90us  [CUDA memcpy DtoH]

      API calls:   89.23%  189.13ms         3  63.045ms  105.94us  188.86ms  cudaMalloc

                   10.09%  21.383ms        22  971.95us  17.322us  1.7658ms  cudaMemcpy

                    0.25%  533.80us        97  5.5030us     172ns  379.31us  cuDeviceGetAttribute

                    0.24%  512.54us         3  170.85us  163.89us  174.59us  cudaFree

                    0.09%  186.85us         1  186.85us  186.85us  186.85us  cuDeviceTotalMem

                    0.08%  162.32us        10  16.232us  7.4320us  50.629us  cudaLaunchKernel

                    0.02%  38.694us         1  38.694us  38.694us  38.694us  cuDeviceGetName

                    0.00%  3.8060us         1  3.8060us  3.8060us  3.8060us  cuDeviceGetPCIBusId

                    0.00%  1.3010us         3     433ns     208ns     825ns  cuDeviceGetCount

                    0.00%     766ns         2     383ns     186ns     580ns  cuDeviceGet

                    0.00%     300ns         1     300ns     300ns     300ns  cuDeviceGetUuid</code></pre>

<aside class="special"><p><strong>Tip:</strong> Once you have verified your results, make sure that you commit your changes to your local git repository.</p>

</aside>

<h2 is-upgraded><strong>Next steps</strong></h2>

<p>Congratulations! So far, you&#39;ve learned how to allocate and manage memory on the GPU and how to launch a GPU kernel. Right now, we have the code in a state where, every iteration, data is copied to the GPU before calling smoothField_gpu and from the GPU after calling smoothField_gpu. This situation happens quite often when porting to GPUs for the first time.</p>

<p>The next step in this codelab is to offload the resetF routine to the GPU, even though it does not take up a lot of time. We want to offload it to the GPU so that we can move the hipMemcpy calls outside of the iteration loop in main and reduce the number of times data is transmitted across the PCI bus.</p>





      </google-codelab-step>

    

      <google-codelab-step label="(Optional) Offload the resetF Kernel to the GPU" duration="10">

        <p>In this section, we are going to offload the <code>resetF</code> routine in <code>smoother.c</code> to the GPU so that we can migrate <code>hipMemcpy</code> calls outside of the iteration loop in <code>main.c</code>. By this point, you have worked through the mechanics for porting a routine to the GPU. Additionally, for this application, we already have all of the necessary data on the GPU that the <code>resetF</code> routine depends on.</p>

<ol type="1" start="1">

<li>Add <code>resetF_gpu</code> definition to <code>smoother.h</code></li>

</ol>

<pre><code>__global__ void resetF_gpu( real *f, real *smoothF, int nx, int ny, int buf );</code></pre>

<ol type="1" start="2">

<li>Add <code>resetF_gpu</code> to <code>smoother.c</code></li>

</ol>

<pre><code>__global__ void resetF_gpu( real *f, real *smoothF, int nx, int ny, int buf )

{

  size_t i = hipThreadIdx_x + hipBlockIdx_x*hipBlockDim_x + buf;

  size_t j = hipThreadIdx_y + hipBlockIdx_y*hipBlockDim_y + buf;

  int iel = i + nx*j;

  if( i &gt;= buf &amp;&amp; i &lt; nX-buf &amp;&amp; j &gt;= buf &amp;&amp; j&lt; nY-buf){

    f[iel] = smoothF[iel];

  }

}</code></pre>

<ol type="1" start="3">

<li>Replace <code>resetF</code> with <code>resetF_gpu</code> in <code>main.c</code>, move the <code>hipMemcpy</code> host-to-device calls before the iteration loop, and move the <code>hipMemcpy</code> device-to-host call after the iteration loop.</li>

</ol>

<pre><code>  hipMemcpy(f_dev, f, nElements*sizeof(real), hipMemcpyHostToDevice);



  for( int iter=0; iter&lt;nIter; iter++){



    // Run the smoother

    hipLaunchKernelGGL((smoothField_gpu), dim3(gridDimX,gridDimY,1), dim3(threadsPerBlockX,threadsPerBlockY,1), 0, 0,

                        smoothOperator.weights_dev, f_dev, smoothF_dev, nx, ny, smoothOperator.dim );



    // Reassign smoothF to f

    hipLaunchKernelGGL((resetF_gpu), dim3(gridDimX,gridDimY,1), dim3(threadsPerBlockX,threadsPerBlockY,1), 0, 0, f_dev, smoothF_dev, nx, ny, buf );

  }

  // Copy smoothF_dev from device to host

  hipMemcpy(smoothF, smoothF_dev, nElements*sizeof(real), hipMemcpyDeviceToHost);</code></pre>

<ol type="1" start="4">

<li>Recompile the smoother2d application</li>

</ol>

<pre><code>$ make</code></pre>

<ol type="1" start="5">

<li>Verify that the solution output agrees with your reference output</li>

</ol>

<pre><code>$ ./smoother2d 1000 10

$ diff function.txt reference/function.txt

$ diff smooth-function.txt reference/smooth-function.txt</code></pre>

<ol type="1" start="6">

<li>You can verify that the the number of hipMemcpy calls is now reduced.</li>

</ol>

<ol type="1" start="1">

<li>For AMD platforms, use <code>rocprof</code> with the <code>--hip-trace</code> flag. Running rocprof will create a file called <code>profile.json</code>. </li>

<li>For Nvidia platforms, use <code>nvprof</code>. </li>

</ol>

<pre><code>$ nvprof ./smoother2d 1000 10

==5017== NVPROF is profiling process 5017, command: ./smoother2d 1000 10

==5017== Profiling application: ./smoother2d 1000 10

==5017== Profiling result:

            Type  Time(%)      Time     Calls       Avg       Min       Max  Name

 GPU activities:   83.03%  9.3196ms        10  931.96us  931.14us  934.88us  smoothField_gpu(float*, float*, float*, int, int, int)

                    7.37%  826.91us         3  275.64us  1.4400us  415.81us  [CUDA memcpy HtoD]

                    5.91%  662.82us        10  66.281us  65.536us  67.616us  resetF_gpu(float*, float*, int, int, int)

                    3.70%  415.27us         1  415.27us  415.27us  415.27us  [CUDA memcpy DtoH]

      API calls:   93.01%  167.17ms         3  55.725ms  106.73us  166.94ms  cudaMalloc

                    6.40%  11.511ms         4  2.8777ms  11.740us  10.515ms  cudaMemcpy

                    0.27%  493.11us         3  164.37us  152.91us  180.26us  cudaFree

                    0.11%  202.57us        97  2.0880us     204ns  83.892us  cuDeviceGetAttribute

                    0.11%  197.07us         1  197.07us  197.07us  197.07us  cuDeviceTotalMem

                    0.06%  111.06us        20  5.5530us  3.8360us  29.368us  cudaLaunchKernel

                    0.02%  37.002us         1  37.002us  37.002us  37.002us  cuDeviceGetName

                    0.00%  4.3920us         1  4.3920us  4.3920us  4.3920us  cuDeviceGetPCIBusId

                    0.00%  2.0330us         3     677ns     237ns  1.4970us  cuDeviceGetCount

                    0.00%     951ns         2     475ns     243ns     708ns  cuDeviceGet

                    0.00%     393ns         1     393ns     393ns     393ns  cuDeviceGetUuid

</code></pre>

<aside class="special"><p><strong>Tip:</strong> Once you have verified your results, make sure that you commit your changes to your local git repository.</p>

</aside>





      </google-codelab-step>

    

      <google-codelab-step label="Congratulations" duration="0">

        <p>In this codelab, you learned how to port serial CPU-only routines in C to GPUs using HIP. To do this, you created device copies of CPU arrays and learned how to copy data from the CPU to the GPU and vice versa. You also learned how to write HIP kernels and launch them from the host. </p>

<p>In the process of doing this, you practiced a strategy for porting to GPUs that included the following steps to make incremental changes to your own source code :</p>

<ol type="1" start="1">

<li>Profile - Find out the hotspots in your code and understand the dependencies with other routines</li>

<li>Plan - Determine what routine you want to port, what data needs to be present on the GPU, and what data needs to be copied back to the CPU after execution</li>

<li>Implement &amp; Verify - Create the necessary device data, insert the appropriate hipMemcpy calls, write an equivalent GPU kernel, and use hipLaunchKernelGGL to launch the GPU kernel. Run your application&#39;s tests and verify the results are correct. Check with a profiler that the new routine and the necessary hipMemCpy calls are being executed.</li>

<li>Commit - Once you have verified correctness and the expected behavior, commit your changes and start the process over again.</li>

</ol>

<h2 is-upgraded><strong>Further reading</strong></h2>

<ul>

<li><a href="https://rocmdocs.amd.com/en/latest/Programming_Guides/HIP-GUIDE.html" target="_blank">HIP Programming Guide</a></li>

<li><a href="https://rocm-developer-tools.github.io/HIP/" target="_blank">HIP API Documentation</a></li>

<li><a href="https://docs.nvidia.com/cuda/floating-point/index.html#fused-multiply-add-fma" target="_blank">Fused Multiply-Add on Nvidia hardware</a></li>

</ul>

<h2 is-upgraded><strong>Reference docs</strong></h2>





      </google-codelab-step>

    

  </google-codelab>



  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>

  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>

  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>

  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>



</body>

</html>

